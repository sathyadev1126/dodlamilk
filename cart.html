<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Cart — Morning Received</title>
<style>
  body{font-family:Arial;margin:12px;max-width:900px}
  .panel{background:#fff;padding:12px;border-radius:8px;box-shadow:0 1px 3px rgba(0,0,0,.06);margin-top:10px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:8px;border-bottom:1px solid #eee;font-size:14px;text-align:left}
  input[type=number]{width:80px;padding:6px}
  button{padding:8px;border:0;border-radius:6px;background:#0b74ff;color:#fff;cursor:pointer}
  .danger{background:#ff4d4f}
  .muted{color:#666;font-size:13px}
  .row{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<header><h1>Cart — Morning Received</h1></header>

<div class="panel">
  <div class="muted">Items you added from catalog. Adjust received quantity and press "Confirm Received" to save into today's transactions.</div>
  <table id="cartTable">
    <thead><tr><th>Item</th><th>Unit ₹</th><th>Qty (received)</th><th>Sub total</th><th></th></tr></thead>
    <tbody></tbody>
  </table>

  <div style="margin-top:12px;display:flex;gap:8px">
    <button id="confirm" >Confirm Received → Save to Today</button>
    <button id="clearCart" class="danger">Clear Cart</button>
    <a href="dashboard.html" style="margin-left:auto"><button>Open Dashboard</button></a>
  </div>

  <div style="margin-top:10px" class="muted">Note: Confirm will convert cart items into recorded transactions (qty used). No customer data.</div>
</div>

<script>
(function(){
  // Keys
  const PROD_KEY = 'milk_products_v1';         // published products from catalog
  const CART_KEY = 'milk_cart_v1';             // {catalogId, items: [{name,price,qty}]}
  const TX_KEY = 'milk_tx_v1';
  const CATALOG_ORDER_KEY = 'milk_catalog_order_v1';
  const bc = ('BroadcastChannel' in window) ? new BroadcastChannel('milkshop_channel') : null;

  // Utilities
  function readJSON(key){ try { return JSON.parse(localStorage.getItem(key) || 'null'); } catch(e){ return null; } }
  function saveJSON(key, value){ localStorage.setItem(key, JSON.stringify(value)); }

  function loadProducts(){ // returns [{name,price}, ...]
    const raw = localStorage.getItem(PROD_KEY);
    if(!raw) return [];
    try { return JSON.parse(raw); } catch(e){ return []; }
  }

  function loadCart(){
    return readJSON(CART_KEY); // may be null
  }

  function saveCart(cart){
    if(!cart || !cart.items || !cart.catalogId) {
      localStorage.removeItem(CART_KEY);
    } else {
      saveJSON(CART_KEY, cart);
    }
    // notify others
    if(bc) bc.postMessage({type:'cart-change'});
    else localStorage.setItem('milkshop_signal', Date.now().toString());
  }

  // Get current active catalog id (most recent)
  function currentCatalogId(){
    const order = readJSON(CATALOG_ORDER_KEY) || [];
    return order[0] || ('catalog-' + new Date().toISOString().slice(0,10));
  }

  // Merge products into cart:
  // - If cart missing or cart.catalogId !== current, create new cart with products and qty 0
  // - If same catalog, update price for existing products and add any new products with qty 0
  // - Do not delete items that exist in cart but not in published products (so manual entries persist)
  function syncCartWithProducts(){
    const products = loadProducts(); // list from catalog
    const catalogId = currentCatalogId();
    let cart = loadCart();

    if(!cart || cart.catalogId !== catalogId){
      // new cart for this catalog
      cart = { catalogId: catalogId, items: products.map(p => ({ name: p.name, price: Number(p.price||0), qty: 0 })) };
      saveCart(cart);
      return cart;
    }

    // merge: map existing by name
    const map = {};
    cart.items.forEach(it => { map[it.name] = { ...it }; });

    // update price for existing or add new
    products.forEach(p=>{
      if(map[p.name]){
        map[p.name].price = Number(p.price||0); // update price
      } else {
        map[p.name] = { name: p.name, price: Number(p.price||0), qty: 0 };
      }
    });

    // keep other items that were in cart but not in products (do nothing)
    // rebuild items array preserving original order for existing ones, then add new ones at end
    const newItems = [];
    // preserve original cart order
    cart.items.forEach(it=>{
      if(map[it.name]) {
        newItems.push(map[it.name]);
        delete map[it.name];
      } else {
        // if item was in cart but not in products, keep it
        newItems.push(it);
      }
    });
    // remaining map entries are new products not in original cart — append
    Object.keys(map).forEach(k => {
      newItems.push(map[k]);
    });

    cart.items = newItems;
    cart.catalogId = catalogId;
    saveCart(cart);
    return cart;
  }

  // Render cart table
  function render(){
    const cart = loadCart();
    const tbody = document.querySelector('#cartTable tbody');
    tbody.innerHTML = '';
    if(!cart || !cart.items || !cart.items.length){
      tbody.innerHTML = '<tr><td colspan="5" class="muted">Cart empty. Add items from catalog.</td></tr>';
      return;
    }

    cart.items.forEach((it, i) => {
      const subtotal = Number(it.qty||0) * Number(it.price||0);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${escapeHtml(it.name)}</td>
        <td>₹${Number(it.price||0).toFixed(2)}</td>
        <td><input type="number" min="0" value="${it.qty}" data-index="${i}" class="qtyCell" /></td>
        <td>₹${subtotal.toFixed(2)}</td>
        <td><button data-index="${i}" class="remove">Remove</button></td>
      `;
      tbody.appendChild(tr);
    });

    // attach handlers
    document.querySelectorAll('.qtyCell').forEach(inp => {
      inp.addEventListener('change', e => {
        const idx = Number(e.target.dataset.index);
        const cart2 = loadCart(); if(!cart2) return;
        cart2.items[idx].qty = Math.max(0, Number(e.target.value) || 0);
        saveCart(cart2);
        render(); // re-render to update subtotal
      });
    });

    document.querySelectorAll('.remove').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = Number(btn.dataset.index);
        const cart2 = loadCart(); if(!cart2) return;
        cart2.items.splice(idx, 1);
        saveCart(cart2);
        render();
      });
    });
  }

  // Confirm: convert cart items into transactions under today's catalog
  document.getElementById('confirm').addEventListener('click', ()=>{
    const cart = loadCart();
    if(!cart || !cart.items || !cart.items.length) return alert('Cart empty');
    const catalogId = currentCatalogId() || cart.catalogId || ('catalog-' + new Date().toISOString().slice(0,10));
    // Build tx entries
    let tx = JSON.parse(localStorage.getItem(TX_KEY) || '[]');
    cart.items.forEach(it=>{
      const qty = Number(it.qty) || 0;
      if(qty <= 0) return;
      tx.push({
        id: Date.now().toString(36) + Math.random().toString(36).slice(2,6),
        catalogId,
        name: it.name,
        price: Number(it.price) || 0,
        qty: qty,
        time: new Date().toISOString()
      });
    });
    localStorage.setItem(TX_KEY, JSON.stringify(tx));
    // clear cart for this catalog (but keep catalogId so next sync will create new)
    localStorage.removeItem(CART_KEY);
    // notify others
    if(bc) bc.postMessage({type:'tx-added-batch'});
    else localStorage.setItem('milkshop_signal', Date.now().toString());
    alert('Received items recorded to Today.');
    // after confirm, ensure cart rebuilt from published products (fresh)
    syncCartWithProducts();
    render();
  });

  document.getElementById('clearCart').addEventListener('click', ()=>{
    if(!confirm('Clear cart?')) return;
    localStorage.removeItem(CART_KEY);
    if(bc) bc.postMessage({type:'cart-change'});
    else localStorage.setItem('milkshop_signal', Date.now().toString());
    render();
  });

  // Respond to external changes (catalog publish or other tab edits)
  function handleExternalEvent(e){
    // If products published/cleared, re-sync and render
    if(bc){
      // BroadcastChannel messages handled below
    } else {
      if(e.key && [PROD_KEY, 'milkshop_signal', CATALOG_ORDER_KEY].includes(e.key)) {
        syncCartWithProducts();
        render();
      }
    }
  }
  window.addEventListener('storage', handleExternalEvent);

  if(bc){
    bc.onmessage = function(ev){
      const t = ev.data && ev.data.type;
      if(['products-published','products-cleared','cart-change','products-cleared','tx-added-batch'].includes(t)){
        syncCartWithProducts();
        render();
      }
    };
  }

  // Utility
  function escapeHtml(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Initial sync + render
  syncCartWithProducts();
  render();

  // periodic safeguard to keep cart synced if something missed
  setInterval(()=>{ syncCartWithProducts(); }, 2000);

})();
</script>

</body>
</html>
